apiVersion: v1
kind: ServiceAccount
metadata:
  name: log-collector
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: log-collector
rules:
  - apiGroups: [""]
    resources: ["pods", "pods/log"]
    verbs: ["get", "watch", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: log-collector
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: log-collector
subjects:
  - kind: ServiceAccount
    name: log-collector
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: log-collector-script
data:
  collector.sh: |
    #!/bin/bash
    LOKI_URL="http://loki:3100/loki/api/v1/push"
    
    push_to_loki() {
      local app="$1" pod="$2" line="$3"
      local ts=$(date +%s)000000000
      local level="info" service="$app"
      
      # JSON format: "level":"info"
      if [[ "$line" =~ \"level\":\"([^\"]+)\" ]]; then
        level="${BASH_REMATCH[1]}"
      # Logfmt format: level=info or level=INFO
      elif [[ "$line" =~ level=([a-zA-Z]+) ]]; then
        level="${BASH_REMATCH[1],,}"
      # Java/Spring: INFO, WARN, ERROR, DEBUG at start or after timestamp
      elif [[ "$line" =~ (^|[[:space:]])(INFO|WARN|ERROR|DEBUG|TRACE|FATAL)([[:space:]]|$) ]]; then
        level="${BASH_REMATCH[2],,}"
      fi
      
      # Service extraction
      [[ "$line" =~ \"service\":\"([^\"]+)\" ]] && service="${BASH_REMATCH[1]}"
      [[ "$line" =~ service=([^[:space:]]+) ]] && service="${BASH_REMATCH[1]}"
      
      local safe="${line//\\/\\\\}"
      safe="${safe//\"/\\\"}"
      safe="${safe//$'\n'/\\n}"
      safe="${safe//$'\r'/}"
      
      curl -s -X POST "$LOKI_URL" -H "Content-Type: application/json" \
        -d "{\"streams\":[{\"stream\":{\"app\":\"$app\",\"pod\":\"$pod\",\"namespace\":\"$NAMESPACE\",\"level\":\"$level\",\"service\":\"$service\"},\"values\":[[\"$ts\",\"$safe\"]]}]}" >/dev/null 2>&1 &
    }
    
    tail_pod() {
      local pod="$1" app="$2"
      echo "Tailing $pod"
      kubectl logs -f --tail=100 "$pod" -n "$NAMESPACE" 2>/dev/null | while read -r line; do
        [ -n "$line" ] && push_to_loki "$app" "$pod" "$line"
      done
    }
    
    echo "Log collector starting"
    TAILED=""
    while true; do
      PODS=$(kubectl get pods -n "$NAMESPACE" -o jsonpath='{range .items[?(@.status.phase=="Running")]}{.metadata.name},{.metadata.labels.app}{"\n"}{end}' 2>/dev/null)
      while IFS=, read -r pod app; do
        if [ -n "$pod" ] && [ -n "$app" ] && [[ ! "$TAILED" =~ "$pod" ]]; then
          TAILED="$TAILED $pod"
          tail_pod "$pod" "$app" &
        fi
      done <<< "$PODS"
      sleep 60
    done
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: log-collector
  labels:
    app: log-collector
spec:
  replicas: 1
  selector:
    matchLabels:
      app: log-collector
  template:
    metadata:
      labels:
        app: log-collector
    spec:
      serviceAccountName: log-collector
      containers:
        - name: collector
          image: bitnami/kubectl:latest
          command: ["/bin/bash", "/scripts/collector.sh"]
          env:
            - name: NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
          volumeMounts:
            - name: script
              mountPath: /scripts
          resources:
            requests:
              cpu: 50m
              memory: 256Mi
            limits:
              cpu: 200m
              memory: 512Mi
      volumes:
        - name: script
          configMap:
            name: log-collector-script
            defaultMode: 0755